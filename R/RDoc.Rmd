---
title: "Assignment V"
author: ""
date: "May 15, 2018"
output: html_document
---

### Due Date: Friday May 22 at 11:59 pm.

```{r}
rm(list=ls())
library(e1071)
library(ggplot2)
library(ROCR)
```


Q1)  Generate a simulated two-class data set with 300 observations and two features in which there is a visible but non-linear separation between the two classes. Insert your code below. Include a plot of all data points labeled by their class type. 
Hint: You can use the methods similar to the lecture notes to enforce non-linear separation. Allocations of the number of observation in each class is your choice. 

```{r}
# Insert code here

set.seed(1)
x <- matrix(rnorm(300*2), ncol =2)
x[1:150,] <- x[1:150,] + 2
x[151:200,] <- x[151:200,] -2
y <- c(rep(1,200), rep(-1, 100))
d.train <- data.frame(x=x, y = as.factor(y))
print(summary(d.train))

d.train <- data.frame(X1 = x[,1], X2 = x[,2],
                      Y = as.factor(y))

g <- ggplot(d.train, aes(x = X1, y=X2, color=Y)) + 
  geom_point(shape=1)
plot(g)
```

Q2) Buid a support vector machines with a radial kernel that performs classification on the above dataset. Use tune() to choose the best cost (as well as gamma) parameters for each SVM. Show all code below including summary of the tune() output.

```{r}
# Insert code here
m1.svm <- svm(Y ~ X2 + X1, data = d.train,
              kernel = "radial",
              cost = 10,
              scale = FALSE) 

m1.svm.tune <- tune(svm, Y~X2 + X1,
                    data = d.train, kernel = "radial",
                    ranges = list(gamma = 2^(-1:1),cost=c(0.01, 1, 10, 100, 1000)))

summary(m1.svm.tune)

m2.svm <- svm(y ~ ., data = d.train,
              kernel = "radial", 
              gamma = 2,
              cost = 1)
  
```

Q3) Perform prediction on a test dataset on 300 observations that you can create similar to Q1.  Insert your code below. Report your prediction accuracy. 


```{r}
# Insert code here. 
set.seed (1)
x=matrix (rnorm (200*2) , ncol =2)
x[1:100 ,]=x[1:100 ,]+2
x[101:150 ,]= x[101:150 ,] -2
y=c(rep (1 ,150) ,rep (2 ,50) )
dat=data.frame(x=x,y=as.factor (y))

sample_size = floor(.70*nrow(dat)) 

set.seed(123)  
t_index <- sample(seq_len(nrow(dat)), size = sample_size)
                  
d.train = dat[t_index,]
d.test = dat[-t_index,]

train = sample(200,100)
svmfit = svm(y~., data=dat[train,], kernel="radial", gamma = 1, cost = 1)

summary(svmfit) 

svmfit = svm(y ~., data=d.train, kernel = "radial", gamma = 1, cost = 1e5) 

m2.svm <- svm(y ~., data = d.train, kernel = "radial", cost = 1)  

set.seed(1)
tune.out = tune(svm, y~., data = dat[train,], kernel = "radial", ranges = list(cost=c(0.1,1,10,100,1000),
                                                                           gamma = c(0.5,1,2,3,4)))
summary(tune.out) 

table(true=d.test$y, pred=predict(m2.svm, newdata = d.test)) 


```

